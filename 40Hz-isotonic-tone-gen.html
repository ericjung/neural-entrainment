<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Gapless 40 Hz @ 48 kHz</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 2rem; }
  button { margin-right:.5rem; }
</style>
<h1>Gapless 40 Hz @ 48 kHz</h1>
<div>
  <label>Frequency <input id="freq" type="number" value="40"></label>
  <label>Duration (s) <input id="dur" type="number" value="10"></label>
  <label>Sample rate <input id="sr" type="number" value="48000"></label>
  <label>Amplitude <input id="amp" type="number" value="0.4" step="0.01"></label>
</div>
<div style="margin-top:.5rem">
  <button id="build">Build buffer</button>
  <button id="play">Play (loop)</button>
  <button id="stop">Stop</button>
</div>

<script>
let ctx, buffer, src;

function ensureCtx() {
  if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
}

function generateInt16PCM({ freq=40, durationSec=10, sampleRate=48000, amplitude=0.4 }) {
  const numSamples = Math.floor(sampleRate * durationSec);
  const pcm = new Int16Array(numSamples);
  for (let i = 0; i < numSamples; i++) {
    const t = i / sampleRate;
    // Int16, Math.round, no fades
    pcm[i] = Math.round(Math.sin(2 * Math.PI * freq * t) * 32767 * amplitude);
  }
  return { pcm, sampleRate };
}

function int16ToFloat32(int16) {
  const f32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) f32[i] = int16[i] / 32768;
  return f32;
}

function buildBuffer() {
  const freq = parseFloat(document.getElementById('freq').value);
  const durationSec = parseFloat(document.getElementById('dur').value);
  const sampleRate = parseInt(document.getElementById('sr').value, 10);
  const amplitude = parseFloat(document.getElementById('amp').value);

  // Generate PCM, then convert to Float32 for Web Audio
  const { pcm } = generateInt16PCM({ freq, durationSec, sampleRate, amplitude });
  ensureCtx();

  // Create AudioBuffer at desired rate (ctx.sampleRate can differ; use resample if needed)
  if (ctx.sampleRate !== sampleRate) {
    // Simple resample by recreating context at target rate if possible
    ctx.close();
    ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
  }

  buffer = ctx.createBuffer(1, pcm.length, sampleRate);
  buffer.getChannelData(0).set(int16ToFloat32(pcm));
}

function playLoop() {
  if (!buffer) buildBuffer();
  ensureCtx();

  // AudioBufferSourceNode cannot be restarted; make a fresh one each time
  src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  src.loopStart = 0;
  src.loopEnd = buffer.duration; // exact 10s is gapless
  src.connect(ctx.destination);
  src.start();
}

function stop() {
  if (src) { try { src.stop(); } catch(_){} src.disconnect(); src = null; }
}

document.getElementById('build').onclick = buildBuffer;
document.getElementById('play').onclick = async () => {
  ensureCtx();
  if (ctx.state === 'suspended') await ctx.resume(); // iOS/mobile gesture requirement
  playLoop();
};
document.getElementById('stop').onclick = stop;

// Build once so Play works immediately
buildBuffer();
</script>
</html>
