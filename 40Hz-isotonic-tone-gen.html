<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Gapless 40 Hz @ 48 kHz</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 2rem; background-color: black; color: white}
  label { margin-right: 1rem; display:inline-block; }
  input { width: 6rem; }
  button { margin-right: .5rem; }
  button:disabled { opacity: .6; cursor: not-allowed; }
</style>

<h1>Neural Entrainment - gapless loop 40 Hz @ 48 kHz</h1>
<div>
  <label>Frequency <input id="freq" type="number" value="40" min="1" max="20000" step="1"></label>
  <label>Duration (s) <input id="dur" type="number" value="10" min="1" max="600" step="1"></label>
  <label>Sample rate <input id="sr" type="number" value="48000" min="8000" max="192000" step="1"></label>
  <label>Amplitude <input id="amp" type="number" value="0.4" min="0" max="1" step="0.01"></label>
</div>
<div style="margin-top:.5rem">
  <button id="play">Play (loop)</button>
  <button id="stop">Stop</button>
</div>

<script>
let ctx = null, buffer = null, src = null;
const $play = document.getElementById('play');
const $stop = document.getElementById('stop');

/** Ensure we have an AudioContext at the desired sampleRate */
async function ensureCtx(sampleRate) {
  if (!ctx || ctx.sampleRate !== sampleRate) {
    if (ctx) { try { await ctx.close(); } catch(_){} }
    const AC = window.AudioContext || window.webkitAudioContext;
    ctx = new AC({ sampleRate });
  }
  if (ctx.state === 'suspended') await ctx.resume();
  return ctx;
}

/** Float32 generation */
function generateFloat32({ freq, durationSec, sampleRate, amplitude }) {
  const numSamples = Math.floor(durationSec * sampleRate);
  const data = new Float32Array(numSamples);
  const twoPiF = 2 * Math.PI * freq;
  for (let i = 0; i < numSamples; i++) {
    const t = i / sampleRate;
    data[i] = Math.max(-1, Math.min(1, Math.sin(twoPiF * t) * amplitude));
  }
  return data;
}

/** Build (or rebuild) the AudioBuffer from current UI values */
async function buildBufferFromUI() {
  const freq = parseFloat(document.getElementById('freq').value);
  const durationSec = parseFloat(document.getElementById('dur').value);
  const requestedRate = parseInt(document.getElementById('sr').value, 10);
  const amplitude = parseFloat(document.getElementById('amp').value);

  await ensureCtx(requestedRate);
  const actualRate = ctx.sampleRate; // may differ if browser ignores hint
  const samples = generateFloat32({ freq, durationSec, sampleRate: actualRate, amplitude });

  buffer = ctx.createBuffer(1, samples.length, actualRate);
  buffer.getChannelData(0).set(samples);
}

/** Start looping */
async function playLoop() {
  // prevent double play
  if (src) return;

  await buildBufferFromUI();

  src = ctx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  src.loopStart = 0;
  src.loopEnd = buffer.duration;
  src.connect(ctx.destination);
  src.start();

  // Disable Play while playing
  $play.disabled = true;

  // If loop=false, when audio ends re-enable Play
  src.onended = () => { src = null; $play.disabled = false; };
}

/** Stop playback */
function stop() {
  if (src) {
    try { src.stop(); } catch(_) {}
    try { src.disconnect(); } catch(_) {}
    src = null;
  }
  // Re-enable Play button after stopping
  $play.disabled = false;
}

$play.onclick = async () => {
  await ensureCtx(parseInt(document.getElementById('sr').value, 10));
  if (ctx.state === 'suspended') await ctx.resume();
  playLoop();
};
$stop.onclick = stop;
</script>
</html>
