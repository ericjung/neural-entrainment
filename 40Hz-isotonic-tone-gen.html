<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neural Entrainment</title>
<meta name="theme-color" content="#0b0f14" />

<!-- iOS Add-to-Home-Screen essentials (Apple ignores most of web manifest) -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Neural Entrainment">
<link rel="apple-touch-icon" href="brain-180.png">
<link rel="apple-touch-icon" sizes="120x120" href="brain-120.png">
<link rel="apple-touch-icon" sizes="152x152" href="brain-152.png">
<link rel="apple-touch-icon" sizes="167x167" href="brain-167.png">
<link rel="apple-touch-icon" sizes="180x180" href="brain-180.png">

<style>
  :root { --bg:#0b0f14; --panel:#0f141b; --fg:#e6f1ff; --muted:#93a4bb; --border:#1e2a36; --pill:#0f1f2d; --ok:#23c55e; --warn:#60a5fa; }
  html,body { height:100%; }
  body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:var(--fg); display:grid; place-items:center; }
  main { width:min(760px,94vw); padding:22px; background:var(--panel); border:1px solid var(--border); border-radius:14px; box-shadow:0 6px 30px rgba(0,0,0,.35); text-align:center; }
  h1 { margin:0 0 12px; font-size:20px; }
  .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin:10px 0; justify-content:center; }
  button, input[type="range"] { background:#131a22; color:var(--fg); border:1px solid var(--border); border-radius:10px; }
  button { padding:10px 14px; font-weight:600; cursor:pointer; }
  input[type="range"] { height:36px; padding:0 6px; }
  .val { min-width:74px; text-align:right; color:#cfe3ff; font-variant-numeric:tabular-nums; }
  .timer { font-size:28px; font-variant-numeric:tabular-nums; padding:6px 10px; border:1px solid var(--border); border-radius:10px; min-width:140px; text-align:center; background:#111824; }
  .status { display:inline-flex; align-items:center; gap:.5ch; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--pill); color:var(--muted); font-size:14px; }
  .dot { width:8px; height:8px; border-radius:50%; background:#6b7280; display:inline-block; }
  .dot.on { background:var(--ok); }
  .dot.am { background:var(--warn); }
  audio { display:none; }
</style>
</head>
<body>
<main>
  <h1>Neural Entrainment</h1>

  <div class="row">
    <button id="playFileBtn">Play Continuous 40Hz Sine (file)</button>
    <button id="playAMBtn">Play 10kHz pulsed at 40Hz (file)</button>
    <button id="stopBtn">Stop</button>
    <div class="timer" id="timer" aria-live="polite">00:00:00</div>
    <button id="resetTimerBtn">Reset Timer</button>
  </div>

  <div class="row" aria-live="polite">
    <div id="status" class="status">
      <span class="dot" id="statusDot" aria-hidden="true"></span>
      <span id="statusText">Stopped</span>
    </div>
  </div>

  <div class="row">
    <label for="gain">Volume</label>
    <input id="gain" type="range" min="0" max="1" step="0.01" value="0.15" />
    <div class="val" id="gainVal">0.15</div>
  </div>

  <!-- Both options use media elements (iOS background is more reliable with <audio>) -->
  <audio id="loopContinuous" src="40hz-continuous-sine.wav" preload="auto" loop playsinline></audio>
  <audio id="loopPulsed"     src="10khz-pulsed-40hz.wav"    preload="auto" loop playsinline></audio>
</main>

<script>
/* -------- Inline manifest + Service Worker for offline PWA ---------- */
(async () => {
  const manifest = {
    name: "Neural Entrainment",
    short_name: "Entrain",
    start_url: location.pathname + location.search,
    display: "standalone",
    background_color: "#0b0f14",
    theme_color: "#0b0f14",
    icons: [
      { "src": "brain-192.png", "sizes": "192x192", "type": "image/png" },
      { "src": "brain-512.png", "sizes": "512x512", "type": "image/png" },
      { "src": "brain-maskable-512.png", "sizes": "512x512", "type": "image/png", "purpose": "maskable" }
    ]
  };
  const manifestBlob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
  const manifestURL = URL.createObjectURL(manifestBlob);
  const link = document.createElement('link');
  link.rel = 'manifest';
  link.href = manifestURL;
  document.head.appendChild(link);

  if ('serviceWorker' in navigator) {
    const CACHE = 'entrain-v1';
    const swCode = `
      const CACHE = '${CACHE}';
      const ASSETS = [
        './',
        location.href,
        '40hz-continuous-sine.wav',
        '10khz-pulsed-40hz.wav',
        'brain-120.png','brain-152.png','brain-167.png','brain-180.png',
        'brain-192.png','brain-512.png','brain-maskable-512.png'
      ];
      self.addEventListener('install', e => {
        e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS)).then(()=>self.skipWaiting()));
      });
      self.addEventListener('activate', e => {
        e.waitUntil((async () => {
          const keys = await caches.keys();
          await Promise.all(keys.filter(k => k !== CACHE).map(k => caches.delete(k)));
          await self.clients.claim();
        })());
      });
      self.addEventListener('fetch', e => {
        const req = e.request;
        if (req.method !== 'GET') return;
        e.respondWith((async () => {
          const cache = await caches.open(CACHE);
          const hit = await cache.match(req, {ignoreVary:true});
          if (hit) return hit;
          try {
            const net = await fetch(req);
            if (net.ok) cache.put(req, net.clone());
            return net;
          } catch {
            // offline fallback to index if navigation
            if (req.mode === 'navigate') {
              const index = await cache.match('./');
              if (index) return index;
            }
            return new Response('Offline', { status: 503 });
          }
        })());
      });
    `;
    const swURL = URL.createObjectURL(new Blob([swCode], { type: 'text/javascript' }));
    try { await navigator.serviceWorker.register(swURL, { scope: './' }); } catch (e) { console.warn('SW registration failed:', e); }
  }
})();

/* ------------------ Seamless Web Audio API Player ------------------ */
(() => {
  const playFileBtn = document.getElementById('playFileBtn');
  const playAMBtn   = document.getElementById('playAMBtn');
  const stopBtn     = document.getElementById('stopBtn');

  const gainSlider  = document.getElementById('gain');
  const gainVal     = document.getElementById('gainVal');

  const statusText  = document.getElementById('statusText');
  const statusDot   = document.getElementById('statusDot');

  let running = null; // 'cont' | 'pulsed' | null
  let audioContext = null;
  let audioBuffers = {};
  let currentSources = [];
  let gainNode = null;
  let nextScheduleTime = 0;

  // Initialize Web Audio API
  async function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioContext.createGain();
      gainNode.connect(audioContext.destination);
      gainNode.gain.value = +gainSlider.value;
    }
    
    if (audioContext.state === 'suspended') {
      await audioContext.resume();
    }
  }

  // Load and decode audio files
  async function loadAudioBuffer(url) {
    if (audioBuffers[url]) return audioBuffers[url];
    
    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      audioBuffers[url] = audioBuffer;
      return audioBuffer;
    } catch (error) {
      console.error('Failed to load audio:', url, error);
      throw error;
    }
  }

  // Schedule seamless looping
  function scheduleLoop(audioBuffer, startTime = null) {
    if (!running) return;

    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(gainNode);

    const now = audioContext.currentTime;
    const scheduleTime = startTime || Math.max(now, nextScheduleTime);
    
    source.start(scheduleTime);
    source.stop(scheduleTime + audioBuffer.duration);
    
    currentSources.push(source);
    
    // Schedule next loop to start exactly when this one ends
    nextScheduleTime = scheduleTime + audioBuffer.duration;
    
    // Clean up finished sources
    source.onended = () => {
      const index = currentSources.indexOf(source);
      if (index !== -1) currentSources.splice(index, 1);
    };

    // Schedule the next iteration
    if (running) {
      const nextTimeout = (nextScheduleTime - now - 0.05) * 1000; // 50ms early
      setTimeout(() => scheduleLoop(audioBuffer), Math.max(0, nextTimeout));
    }
  }

  function setStatus(mode) {
    statusDot.classList.remove('on','am');
    if (mode === 'cont') {
      statusText.textContent = 'Now playing: 40 Hz continuous (file)';
      statusDot.classList.add('on');
    } else if (mode === 'pulsed') {
      statusText.textContent = 'Now playing: 10 kHz pulsed @ 40 Hz (file)';
      statusDot.classList.add('am');
    } else {
      statusText.textContent = 'Stopped';
    }
  }

  async function stopAll() {
    running = null;
    
    // Stop all current sources immediately
    currentSources.forEach(source => {
      try {
        source.stop();
      } catch (e) {}
    });
    
    currentSources = [];
    setStatus(null);
    stopTimer();
  }

  async function playContinuous() {
    await stopAll();
    await initAudioContext();
    
    try {
      const buffer = await loadAudioBuffer('40hz-continuous-sine.wav');
      running = 'cont';
      setStatus('cont');
      nextScheduleTime = audioContext.currentTime;
      scheduleLoop(buffer);
      startTimer();
    } catch (error) {
      console.error('Failed to play continuous:', error);
      setStatus(null);
    }
  }

  async function playPulsed() {
    await stopAll();
    await initAudioContext();
    
    try {
      const buffer = await loadAudioBuffer('10khz-pulsed-40hz.wav');
      running = 'pulsed';
      setStatus('pulsed');
      nextScheduleTime = audioContext.currentTime;
      scheduleLoop(buffer);
      startTimer();
    } catch (error) {
      console.error('Failed to play pulsed:', error);
      setStatus(null);
    }
  }

  playFileBtn.addEventListener('click', playContinuous);
  playAMBtn.addEventListener('click', playPulsed);
  stopBtn.addEventListener('click', stopAll);

  // volume
  gainSlider.addEventListener('input', () => {
    const v = +gainSlider.value;
    gainVal.textContent = v.toFixed(2);
    if (gainNode) {
      gainNode.gain.value = v;
    }
  });

  // Handle page visibility changes
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && audioContext) {
      try {
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
      } catch (e) {
        console.warn('Could not resume audio context:', e);
      }
    }
  });

  // Timer
  const timerEl = document.getElementById('timer');
  const resetBtn = document.getElementById('resetTimerBtn');
  let timerInterval = null, elapsedSeconds = 0;
  const pad = n => n.toString().padStart(2,'0');
  const formatHMS = s => `${pad(Math.floor(s/3600))}:${pad(Math.floor((s%3600)/60))}:${pad(s%60)}`;
  const renderTimer = () => { timerEl.textContent = formatHMS(elapsedSeconds); };
  const startTimer = () => { if (!timerInterval) timerInterval = setInterval(()=>{elapsedSeconds++; renderTimer();},1000); };
  const stopTimer  = () => { clearInterval(timerInterval); timerInterval = null; };
  const resetTimer = () => { elapsedSeconds = 0; renderTimer(); };
  resetBtn.addEventListener('click', resetTimer);
  renderTimer();
})();
</script>
</body>
</html>
